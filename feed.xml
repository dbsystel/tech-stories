<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://jbake.org</link>
    <atom:link href="http://jbake.org/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Thu, 26 Oct 2023 15:02:48 +0000</pubDate>
    <lastBuildDate>Thu, 26 Oct 2023 15:02:48 +0000</lastBuildDate>

    
    <item>
      <title>Migrate Vue 2 to Vue 3</title>
      <link>http://jbake.org/blog/2023/2023-08-21-vue2-vue3-migration.html</link>
      <pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2023/2023-08-21-vue2-vue3-migration.html</guid>
      <description>
      &lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_how_we_migrated_our_vue_2_enterprise_project_to_vue_3&quot;&gt;How we migrated our Vue 2 enterprise project to Vue 3&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_about_me_and_my_team&quot;&gt;About me and my Team&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_where_we_started&quot;&gt;Where we started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_preparations&quot;&gt;Preparations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_migrations_before_the_migration&quot;&gt;Migrations before the migration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_finally_migrate_to_vue_3&quot;&gt;Finally: Migrate to Vue 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_post_migration_steps&quot;&gt;Post-Migration-Steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- endtoc --&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_how_we_migrated_our_vue_2_enterprise_project_to_vue_3&quot;&gt;How we migrated our Vue 2 enterprise project to Vue 3&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s been a while:
Since the 2nd February 2022, Vue 3 became the new default for Vue.js apps.&lt;/p&gt;
&lt;/div&gt;
&lt;!-- teaser --&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s done! Vue 3 is now the default version and the brand new &lt;a href=&quot;http://vuejs.org&quot; class=&quot;bare&quot;&gt;http://vuejs.org&lt;/a&gt; is live! More details in the blog post in case you missed it:
&lt;a href=&quot;https://blog.vuejs.org/posts/vue-3-as-the-new-default.html&quot; class=&quot;bare&quot;&gt;https://blog.vuejs.org/posts/vue-3-as-the-new-default.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://twitter.com/vuejs/status/1490592213184573441?s=20&amp;amp;t=sXiVzjkn_9nfgrYgrBK8SQ&quot;&gt;Tweet from @vuejs on Twitter&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It was a long journey to the final default release of Vue 3 since the first version published on 18th September 2020.
But: even if Vue 3 isn&amp;#8217;t a new thing anymore, there are still a lot of Vue 2 apps which haven&amp;#8217;t been migrated yet.
The migration can be quite heavy since in practice it&amp;#8217;s much more than only following the migration guide.
Projects usually rely also on 3rd-party dependencies which are maybe not available for Vue 3 or not maintained anymore.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this blog post I will give you an insight into how my team mastered the migration and what pitfalls we faced.
I will describe how we planned and migrated our whole Vue 2 codebase to Vue 3 using Pinia as Store-Solution, Vite for our build environment and Vitest for fast unit test executions.
The focus of this article is not to provide a very detailed step-by-step migration guide.
I will focus about what things you should keep in mind, what you can already do before starting the migration and about some pitfalls we pointed out.
However, I will provide you links to more detailed blog posts about specific topics.
Please keep in mind, that the way we solved the migration won&amp;#8217;t probably fit to your very specific setup for 100%, but you can check what parts seem to be good for you and your team.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Vue 2 EOL:&lt;/strong&gt; Please note, that the Vue 2 support will end on December 31st, 2023.
This means there will be no fixes and features provided anymore (unless you are &lt;a href=&quot;https://v2.vuejs.org/lts/&quot;&gt;actively extending the support&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_about_me_and_my_team&quot;&gt;About me and my Team&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To give you a high level overview about our context, I would just like to say a few short words about myself and my team.
I am working at &lt;a href=&quot;https://www.dbsystel.de/dbsystel-en&quot;&gt;DB Systel GmbH&lt;/a&gt;, in a DevOps Team building a Business-to-Government (B2G) solution together with our partner &lt;a href=&quot;https://www.deutschebahnconnect.com&quot;&gt;Deutsche Bahn Connect GmbH&lt;/a&gt; named &lt;a href=&quot;https://www.deutschebahnconnect.com/en/products/curbside-management&quot;&gt;&lt;strong&gt;&lt;em&gt;DB Curbside Management&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;.
Our product focuses on helping cities and councils to effectively manage shared mobility offerings and their jurisdictions dynamically.
They will be able to get insights about statistics, violations of agreements with the mobility providers to regulate a fair and steady distribution of all the different shared mobility vehicles across managed area.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_where_we_started&quot;&gt;Where we started&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;My team added the migration to Vue 3 with the new default setup and tools using &lt;a href=&quot;https://vitejs.dev&quot;&gt;Vite&lt;/a&gt;, &lt;a href=&quot;https://pinia.vuejs.org&quot;&gt;Pinia&lt;/a&gt; and &lt;a href=&quot;https://vitest.dev&quot;&gt;Vitest&lt;/a&gt; to our backlog many months ago, but the switch to Vue 3 as default gave us another push for facing the migration.
We realized pretty fast, that a &lt;em&gt;big-bang&lt;/em&gt; migration wouldn&amp;#8217;t be possible for us, since it will block us releasing new features for quite a long time.
Our codebase contained already ~200 Vue 2 components using the old-fashioned Options API as well as a huge Vuex Store and some libraries that aren&amp;#8217;t compatible with Vue 3.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_preparations&quot;&gt;Preparations&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s start with the preparation of your team and questions you should answer yourself before starting the migration.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first thing you should do is to get comfy with Vue 3, and you should learn about the differences compared to Vue 2 and the options you have.
You can set up a Vue 3 playground app locally and explore yourself the new setup and components.
To know what things will change when starting the migration, I would recommend you the read the following articles in advance:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Official Vue 2 to Vue 3 &lt;a href=&quot;https://v3-migration.vuejs.org&quot;&gt;Migration Guide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Blogpost: &lt;a href=&quot;https://crisp.chat/blog/vuejs-migration&quot;&gt;&quot;Vue.js: How to Migrate a large project from Vue 2 to Vue 3&quot;&lt;/a&gt; from &lt;a href=&quot;https://twitter.com/baptistejamin&quot;&gt;Baptiste Jamin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Official Vue 3 notes about the &lt;a href=&quot;https://vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api&quot;&gt;Composition API&lt;/a&gt; and the relationship / differences compared to the Options API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vue Master Blog-Series by Andy Li &lt;a href=&quot;https://www.vuemastery.com/blog/vue-3-migration-build&quot;&gt;Part 1&lt;/a&gt; | &lt;a href=&quot;https://www.vuemastery.com/blog/migration/&quot;&gt;Part 2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Free Vue Mastery Video Course &lt;a href=&quot;https://www.vuemastery.com/courses/from-vue2-to-vue3/from-vue-2-to-vue-3&quot;&gt;&quot;From Vue 2 to Vue 3&quot;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_update_to_the_latest_minor_vue_2_version&quot;&gt;Update to the latest minor Vue 2 version&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;My first advice is to keep your current app as up-to-date as possible.
Especially when your Vue version is below &lt;code&gt;2.7.x&lt;/code&gt;, I would recommend you to update it.
With Vue &lt;code&gt;2.7.x&lt;/code&gt; &quot;Naruto&quot; release, the Vue team aimed to backport lots of features from Vue 3 to Vue 2 without introducing a breaking change.
This will help you to migrate some things in preparation for a smooth Vue 3 switch.
Check out the &lt;a href=&quot;https://blog.vuejs.org/posts/vue-2-7-naruto.html&quot;&gt;official announcement&lt;/a&gt; and start migrating to the Vue 3 flavour in your Vue 2 app:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_typescript_or_not&quot;&gt;TypeScript or not?&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Are you using TypeScript right now or do you plan to migrate to TypeScript?
In that case you should read the &lt;a href=&quot;https://vuejs.org/guide/typescript/overview.html&quot;&gt;TypeScript Notes for Vue 3&lt;/a&gt;.
Generally I would highly recommend to use TypeScript as the Vue 2 and Vue 3 TypeScript integration is great.
It will help you a lot to reduce runtime errors as hard debugging nights by analyzing bugs in production.
Be prepared, that switching to Typescript might require quite an effort, but it&amp;#8217;s still worth it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_check_your_dependencies&quot;&gt;Check your dependencies&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A big thing you definitely have to check before is: dependencies.
You should check if you are using packages that will rely on Vue 2 and won&amp;#8217;t be available for Vue 3.
Such dependencies will require your attention as they may block you from updating to Vue 3.
In my previous project we weren&amp;#8217;t able to update to Vue 3 a long time since we had a dependency to &lt;a href=&quot;https://bootstrap-vue.org&quot;&gt;BootstrapVue&lt;/a&gt; which wasn&amp;#8217;t working with Vue 3 and isn&amp;#8217;t still.
In such case where a package isn&amp;#8217;t compatible you have the following options:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Check if there is an equivalent package or a fork of your dependency that will support Vue 3. If there is one: be sure it&amp;#8217;s still maintained and alive.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the package is just a Vue-wrapper for a common library, you may need to use the library directly&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find a similar package that supports Vue 3. In this case you have to make sure the new dependency supports all your use-cases, and you have to plan how to migrate this dependency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can contribute to the dependency and help to make it Vue 3 compatible. You may have to check &lt;a href=&quot;https://github.com/vueuse/vue-demi&quot;&gt;VueDemi&lt;/a&gt; which is a great developing utility to create or update Universal Vue Libraries for Vue 2 &amp;amp; 3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Worst Case: Write the features you need by yourself, but be sure to open-source it afterwards ;-)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In all these cases you should make yourself a list of the relevant development tasks with a very rough estimate about how complex the migration will be.
For example write a &lt;code&gt;+&lt;/code&gt; if the dependency migration is straight forward (already Vue 3 compatible).
Write &lt;code&gt;+&lt;/code&gt; for very hard-to-migrate dependencies, where you may need another solution or lib or implement stuff by yourself.
Add Notes about things you shouldn&amp;#8217;t forget when starting the migration.
You should also include development dependencies for example for webpack plugins.
It could look like the following example:&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Vue 2 dependency&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Vue 3 dependency&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;notes&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;estimate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;@dsb-norge/vue-keycloak-js&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;@baloise/vue-keycloak&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;similar API, similar features&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;++&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;v-tooltip&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;floating-vue&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;same lib under the hood with more features&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;+&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;vue2-datepicker&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;vue-datepicker-next&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;same lib with Vue 3 support&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;+&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;vue2-leaflet&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;@vue-leaflet/vue-leaflet&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;same API, but lots of relying components&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;++&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;| vue2-leaflet-draw-toolbar | - | no Vue 3 equivalent | ++ |
| webpack-license-plugin | rollup-plugin-license | different plugin for rollup, with a different API, we need to check / adjust the output format |  |&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_try_out_things_in_a_playground&quot;&gt;Try out things in a playground&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For dependency update / migrations you can&amp;#8217;t estimate, it&amp;#8217;s a good idea to set them up / try them out in an isolated new Vue 3 playground environment.
After playing around, you should be able to estimate the effort.
A good example when having a look at the migration list above would be to try out the &lt;code&gt;rollup-plugin-license&lt;/code&gt; package.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_check_your_current_webpack_environment&quot;&gt;Check your current Webpack environment&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When coming from webpack and planning to migrate to Vite, you should check your webpack config for any special behaviors.
You can use the playground to reflect / try out the setup in Vite.
Here are some points that were interesting for us:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We don&amp;#8217;t need a specific SCSS/SASS/LESS configuration anymore as Vite brings &lt;a href=&quot;https://vitejs.dev/guide/features.html#css-pre-processors&quot;&gt;support for this out-of-the-box&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We needed to migrate the &lt;code&gt;webpack-license-plugin&lt;/code&gt; to &lt;code&gt;rollup-plugin-license&lt;/code&gt; (see above)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vite comes with its own &lt;a href=&quot;https://vitejs.dev/guide/env-and-mode.html&quot;&gt;approach of reading and passing environment variables and build modes&lt;/a&gt; which is quite easy and handy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://vitejs.dev/guide/assets.html&quot;&gt;Static Asset Handling by Vite&lt;/a&gt; is something you should probably know before&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_split_your_store_on_paper&quot;&gt;Split your Store on paper&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When currently using Vuex, you may be lucky, and you have already some modules splitting your store into logical parts.
In our case we had just one big store without any modules as the codebase has evolved over time, and we haven&amp;#8217;t made the step to split the store.
The migration to Pinia can be a good chance to face this now as Pinia lets you easily compose multiple small stores.
You should check your current store configuration and write down the modules that are loosely coupled or even completely independent (e.g. a &lt;code&gt;user&lt;/code&gt; or an &lt;code&gt;auth&lt;/code&gt; store).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_make_the_migration_transparent_and_estimable&quot;&gt;Make the migration transparent and estimable&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The last thing we have done was to create a new epic for the whole migration and to create small estimable tasks.
This was very important as we were now able to identify things we can prepare and do even before we started the migration itself and also tasks we can do in advance.
On the other hand it helped us for the communication with the product owner and to make things transparent.
Please keep in mind to add some time buffer for unexpected things occurring during the migration where you may need some extra time.
For example: the migration from Vuex to Pinia took a lot more time than we thought before.
But: it was definitely worth it.
The TypeScript support is way better and the unification of actions and mutations reduces the Boilerplate code a lot.
We also underestimated the time we needed to migrate the tests.
This was hard by definition but quite time-consuming as I wrote in the introduction: We had a huge Vuex store.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_migrations_before_the_migration&quot;&gt;Migrations before the migration&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Before starting the migration itself you should migrate everything you can, which is not related to Vue 3 / vite.
Here is what we have done in my team before the migration itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_convert_filters_to_functions&quot;&gt;Convert Filters to functions&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Vue 3 kicked out the concept of using filters in the template using the pipe (&lt;code&gt;|&lt;/code&gt;) syntax (&lt;code&gt;{{ expression | myFilter }}&lt;/code&gt;).
Filters are simply functions that can be imported and used directly.
You can already import the functions, use them as a method and then pass through the expression in the template before starting the Vu3 migration:
&lt;code&gt;{{ myFilter(expression) }}&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_update_and_migrate_dependencies&quot;&gt;Update and migrate dependencies&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Update all possible dependencies to their latest versions to make migrations for other libs in advance.
At this step: double-check if vue-specific libs are ready for using with Vue 3 or if there are other libs you have to use.
If you have to change to other libs and this one supports Vue 3, make the migration now.
In our team we had already lots of our dependencies updated, since we are using &lt;a href=&quot;https://www.mend.io/free-developer-tools/renovate/&quot;&gt;Mend (formerly Whitesource) Renovate&lt;/a&gt; for housekeeping and continuous dependency version updates.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When you decide to migrate a dependency to a new one that supports Vue 2 and Vue 3 or which should be replaced with a self-implementation:
Do it in advance before the actual Vue migration.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_isolate_hard_to_migrate_components&quot;&gt;Isolate hard-to-migrate components&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It may happens, you realize, for some of your dependencies a migration won&amp;#8217;t be straight-forward.
In our case we decided some years ago, we want to use &lt;a href=&quot;https://leafletjs.com/&quot;&gt;Leaflet.js&lt;/a&gt; as our map library to display and interact with features on a map.
Therefore we also used a wrapper for Vue 2 applications called &lt;a href=&quot;https://github.com/vue-leaflet/Vue2Leaflet&quot;&gt;Vue2Leaflet&lt;/a&gt; which made us use Leaflet in a declarative manner.
However, this architectural decision was now a problem for us, as not only this dependency is not supposed to use it with Vue 3 but also extensions for this library such as &lt;a href=&quot;https://www.npmjs.com/package/@ozangokhanhergul/leaflet.heat&quot;&gt;Leaflet.heat&lt;/a&gt; needed to be migrated.
To face this issue we&amp;#8217;ve gone one step back and rethink our architectural decision to use Leaflet. At this time there was already a Vue 3 wrapper for leaflet available but not as feature-rich as we needed it.
So we created a new Architectural Decision Record (ADR) to evaluate and choose our future map library as it is a central component of our app and can&amp;#8217;t be easily replaced.
After doing a Proof-of-Concept (PoC), we decided to switch to &lt;a href=&quot;https://openlayers.org/&quot;&gt;OpenLayers&lt;/a&gt; and make use of the &lt;a href=&quot;https://github.com/MelihAltintas/vue3-openlayers&quot;&gt;vue3-openlayers&lt;/a&gt; wrapper too, where we were also able to contribute missing features back into the project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This whole story is probably quite special to my team and our app, but the essential thing here was, that we prepared the central components in parallel to our productive app in a separate repository in isolation.
Therefore, we created the components and defined their props and events with the help of &lt;a href=&quot;https://storybook.js.org/&quot;&gt;Storybook&lt;/a&gt;.
Of course, we also created tests for these components, so that we were prepared to copy over all this into the productive app and replace the existing components later, when we were ready to actually migrate to Vue 3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A drawback with this approach is of course: It probably blocks you with releasing new features or you have to implement them twice during the preparation time (one time for the productive app based on Vue 2, one time for the isolated components based on Vue 3).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_update_your_npm_scripts&quot;&gt;Update your NPM Scripts&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When checking your Vue 3 default setup you will notice that some NPM script names have changed by default.
For example the default command to run the development build and server is now &lt;code&gt;npm run dev&lt;/code&gt; instead of &lt;code&gt;npm run serve&lt;/code&gt;.
You can either change the names back since you are used to the &quot;old&quot; commands, or you can already name your commands in the Vue 2 setup to the new ones to get comfy with it.
Please note that you may have to change the commands in you CI/CD Pipeline too.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_switch_to_vite&quot;&gt;Switch to Vite&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can switch to Vite before updating to Vue 3 this makes the &quot;big bang&quot; migration a bit smaller.
For that, you should install Vite and use the official plugin &lt;a href=&quot;https://www.npmjs.com/package/@vitejs/plugin-vue2&quot;&gt;@vitejs/plugin-vue2&lt;/a&gt;.
You also need to migrate all the webpack plugins and configs.
When the setup is finished, cleanup all the webpack stuff including the config and the dependencies.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;During the migration we noticed, that we haven&amp;#8217;t used &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export&quot;&gt;Type-Only Imports&lt;/a&gt; in all our typescript and &lt;code&gt;.vue&lt;/code&gt; files.
The default Vite setup is configured in such way, Type-Only Imports will be forced when needed, otherwise you&amp;#8217;ll receive errors during the build.
We had the option to either deactivate this strict behavior by setting the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues&quot;&gt;typescript config option &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;&lt;/a&gt; to either &lt;code&gt;preserve&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; (not recommended) or to migrate.
Luckily, there is a community project called &lt;a href=&quot;https://github.com/JamieMason/ts-import-types-cli&quot;&gt;ts-import-types-cli&lt;/a&gt; that will automate a part of this step.
So we just had to run the following command to migrate to Type-Only Imports at places needed:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code data-lang=&quot;bash&quot;&gt;# remove the `--dry-run` flag to migrate actually and not only list the changes
npx ts-import-types-cli --no-organise-imports -p tsconfig.json --dry-run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The bad news: The tool didn&amp;#8217;t find all occurrences of the Type-Only Imports, so when running &lt;code&gt;npm run build&lt;/code&gt;, we caught some more we had to fix manually.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_switch_to_vitest&quot;&gt;Switch to Vitest&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After your migration to Vite, you should make use of Vitest as your new pretty and fast unit testing framework.
In comparison to &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; it comes with a stable out-of-the-box ESM support and faster test executions.
Until now Jest&amp;#8217;s support for ESM is &lt;a href=&quot;https://jestjs.io/docs/ecmascript-modules&quot;&gt;still experimental&lt;/a&gt; (State: Jest Version 29.5).
&lt;a href=&quot;https://vitest.dev/guide/migration.html#migrating-from-jest&quot;&gt;The API is quite similar and mostly compatible to jest&lt;/a&gt;.
If you used Mocha before, the migration shouldn&amp;#8217;t be hard either.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_switch_to_pinia&quot;&gt;Switch to Pinia&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The next big step you should do in advance is the migration of your Vuex store.
You can also do this step after the migration itself and keep Vuex for now.
However, we decided, it&amp;#8217;s a good idea, to migrate the store before and switch to Pinia since the API is a lot simpler and better composable when slicing our big store into chunks.
Furthermore, it comes with better TypeScript support.
At the &lt;a href=&quot;https://pinia.vuejs.org/cookbook/migration-vuex.html&quot;&gt;Pinia-Docs you will find a very detailed Guide for the Migration from Vuex&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_migrate_components&quot;&gt;Migrate Components&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least we decided to migrate all our components to the &lt;a href=&quot;https://vuejs.org/api/composition-api-setup.html&quot;&gt;composition API&lt;/a&gt; with the &lt;a href=&quot;https://vuejs.org/api/sfc-script-setup.html&quot;&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt; syntactical sugar&lt;/a&gt;.
This is a step you can also omit or do in advance, but we recommend using this API since it&amp;#8217;s also a bit more performant, and it reduces the boilerplate code you have to write.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_finally_migrate_to_vue_3&quot;&gt;Finally: Migrate to Vue 3&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You are now prepared to migrate to Vue 3, and you&amp;#8217;ve done already a lot of things which made this step much easier and shorter.
Now you can start the migration of Vue itself.
Keep in mind, that for the actual migration you must migrate the unit tests too as the test utils for vue3 are slightly different.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_migrate_the_source_code&quot;&gt;Migrate the source code&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here we started by adding Vue 3 as well as the &lt;code&gt;@vue/compat&lt;/code&gt; package as described in the &lt;a href=&quot;https://v3-migration.vuejs.org/migration-build.html#migration-build&quot;&gt;Vue 3 Migration Build documentation&lt;/a&gt;.
Also, we needed to update the &lt;code&gt;VueRouter&lt;/code&gt; to version &lt;code&gt;4.x.x&lt;/code&gt; and adjust the configuration.
As good step-by-step guides, I would recommend you again to read the following Blogposts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://crisp.chat/blog/vuejs-migration&quot;&gt;&quot;Vue.js: How to Migrate a large project from Vue 2 to Vue 3&quot;&lt;/a&gt; from &lt;a href=&quot;https://twitter.com/baptistejamin&quot;&gt;Baptiste Jamin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The official Vue 2 to Vue 3 &lt;a href=&quot;https://v3-migration.vuejs.org&quot;&gt;Migration Guide&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you have already prepared some components in isolation to work with Vue 3 as we did:
Of course you should replace the old ones and probably adjust the props or events if the API of your new components changed compared to the Vue 2 ones.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After this step your whole app should work as before (fingers crossed).
The migration of the components itself can be done one by one after the migration until everything is converted to Vue 3.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_migrate_to_vuetest_utilsv2&quot;&gt;Migrate to &lt;code&gt;@vue/test-utils@v2&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After you migrated everything, you need to update to &lt;code&gt;@vue/test-utils@v2&lt;/code&gt;.
The migration should be straight-forward when &lt;a href=&quot;https://test-utils.vuejs.org/migration/&quot;&gt;following the migration guide&lt;/a&gt;.
Nonetheless it can take quite a bit of time depending on the amount of unit tests you have.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_post_migration_steps&quot;&gt;Post-Migration-Steps&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_remove_compatibility_package&quot;&gt;Remove Compatibility Package&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Once every component is migrated, make sure to remove the &lt;code&gt;@vue/compat&lt;/code&gt; and it&amp;#8217;s configuration as you don&amp;#8217;t need it anymore.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_make_use_of_the_teleport_feature&quot;&gt;Make use of the Teleport feature&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that we are using Vue 3, we can use the &lt;a href=&quot;https://vuejs.org/guide/built-ins/teleport.html&quot;&gt;&quot;Teleport&quot;&lt;/a&gt; feature.
Think about components creating their DOM elements deeply in the DOM caused by the component hierarchy but where you would expect the elements to appear somewhere else close to the root.
A good example is displaying a modal conditionally:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code data-lang=&quot;html&quot;&gt;&amp;lt;body&amp;gt;
  &amp;lt;ComponentOne&amp;gt;
    &amp;lt;ComponentTwo&amp;gt;
      &amp;lt;ComponentThree&amp;gt;
        &amp;lt;MyModal v-if=&quot;myCondition&quot;&amp;gt;
      &amp;lt;/ComponentThree&amp;gt;
    &amp;lt;/ComponentTwo&amp;gt;
  &amp;lt;/ComponentOne&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Vue 2, the modal would be rendered and appear inside the &lt;code&gt;ComponentThree&lt;/code&gt;.
Using teleport in &lt;code&gt;MyModal&lt;/code&gt; can lift the element up to the &lt;code&gt;body&lt;/code&gt; tag which makes more sense for common modal dialogs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Migrating from Vue 2 to Vue 3 can be a huge thing and takes quite a bit of time.
But good preparation and pre-migration will make the whole migration process much easier, more estimable and won&amp;#8217;t block you for so long with releasing new features. Compared to writing the whole thing from scratch, we think this was well worth it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I hope this post gave you some inspiration of how you can face the migration of your project.
Happy Migration ‚úåüèº&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Projekt Loom ist da</title>
      <link>http://jbake.org/blog/2023/2023-05-05-loom-threading.html</link>
      <pubDate>Fri, 5 May 2023 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2023/2023-05-05-loom-threading.html</guid>
      <description>
      &lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_threading_wie_es_sein_soll_projekt_loom_ist_da&quot;&gt;Threading wie es sein soll: Projekt Loom ist da&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_virtualisierung_hilft_schon_immer&quot;&gt;Virtualisierung hilft schon immer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_und_der_weg_ins_schlamassel&quot;&gt;‚Ä¶ und der Weg ins Schlamassel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_threads_sind_die_grundlage_der_nebenl√§ufigkeit&quot;&gt;Threads sind die Grundlage der Nebenl√§ufigkeit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_asynchrone_programmierung_als_notl√∂sung&quot;&gt;Asynchrone Programmierung als Notl√∂sung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_projekt_loom_als_rettung&quot;&gt;Projekt Loom als Rettung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_virtualthreads_benutzen_ist_fast_einfacher_als_vermeiden&quot;&gt;VirtualThreads: benutzen ist (fast) einfacher als vermeiden&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_anpassungen_im_eigenen_code&quot;&gt;Anpassungen im eigenen Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_angewohnheiten_hinterfragen&quot;&gt;Angewohnheiten hinterfragen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_synchron_war_nie_schlecht&quot;&gt;Synchron war nie schlecht&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_ausblick_structured_concurrency&quot;&gt;Ausblick: Structured Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- endtoc --&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_threading_wie_es_sein_soll_projekt_loom_ist_da&quot;&gt;Threading wie es sein soll: Projekt Loom ist da&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Es ist endlich so weit - das lang ersehnte Projekt Loom hat seinen Weg in das JDK gefunden!&lt;/p&gt;
&lt;/div&gt;
&lt;!-- teaser --&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Seit √ºber f√ºnf Jahren haben wir uns danach gesehnt, all die Kr√ºcken wie
&lt;a href=&quot;https://www.tutorialspoint.com/java_nio/java_nio_socket_channel.htm&quot;&gt;NIO&lt;/a&gt;,
&lt;a href=&quot;https://www.ideas2it.com/blogs/the-future-interface-the-best-way-for-asynchronous-java-programming/&quot;&gt;asynchrone Programmierung&lt;/a&gt;,
&lt;code&gt;CompletableFutures&lt;/code&gt; und
&lt;code&gt;&lt;a href=&quot;https://www.hackerearth.com/practice/notes/asynchronous-servlets-in-java/&quot;&gt;AsyncServlets&lt;/a&gt;&lt;/code&gt;
hinter uns zu lassen und Java wieder so zu schreiben, wie wir es schon immer wollten.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_virtualisierung_hilft_schon_immer&quot;&gt;Virtualisierung hilft schon immer&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Auf jedem Rechner gibt es Ressourcen, die begrenzt sind. CPU-Zeit ist seit jeher eine knappe Ressource. Gleichzeitig m√ºssen jedoch h√§ufig viele kleine Aufgaben erledigt werden. Heutzutage verwenden wir meist API-Backends, die Anfragen √ºber HTTP erhalten.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sie lesen Daten, transformieren sie und ver√§ndern sie gegebenenfalls. Anschlie√üend wird die Antwort per Netzwerk-IO gesendet. Dabei die Ressourcen effizient zu nutzen, war von Anfang an eine Herausforderung und erforderte viel manuelle Arbeit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Zum Gl√ºck hatte Edsger W. Dijkstra bereits im Jahr 1965 die brillante Idee, den Zugriff auf wertvolle Ressourcen zu virtualisieren. So bekam das
&lt;a href=&quot;https://en.wikipedia.org/wiki/Berkeley_Timesharing_System&quot;&gt;Berkeley Timesharing System&lt;/a&gt;
die
&lt;a href=&quot;http://www.serpentine.com/blog/threads-faq/the-history-of-threads/&quot;&gt;ersten Threads&lt;/a&gt;
der Computer-Geschichte. Das Konzept war einfach: Threads sind kosteng√ºnstig und virtualisieren den Zugriff auf wertvolle Ressourcen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/20230505-loom-threading/bs-threads.svg&quot; alt=&quot;Threading wie die Urahnen - mit einer CPU&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 1. Threading wie die Urahnen - mit einer CPU&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ein Scheduler sorgt daf√ºr, dass blockierte Threads unterbrochen werden und andere Aufgaben ausgef√ºhrt werden k√∂nnen, bis die notwendigen Ressourcen verf√ºgbar sind. Ein wahrhaft revolution√§res Konzept!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Die Welt hat sich seit den ersten Threads des Berkeley Timesharing Systems weiterentwickelt. ‚ÄûModerne‚Äú Betriebssysteme wie
&lt;a href=&quot;https://de.wikipedia.org/wiki/AmigaOS&quot;&gt;AmigaOS&lt;/a&gt;
haben das Konzept des Threading verbessert, indem sie es dem Betriebssystem erlauben, rechnende Prozesse zu unterbrechen und an anderer Stelle fortfahren zu lassen. Anders als bei
&lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-5257/6je9h033n/index.html&quot;&gt;User Threads in SunOS&lt;/a&gt;,
wo der Code im Thread selbst anzeigt, wann er unterbrochen werden soll.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_und_der_weg_ins_schlamassel&quot;&gt;‚Ä¶ und der Weg ins Schlamassel&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Wir haben seitdem viel getan, um das Thread-Konzept kaputt zu bekommen. Wir nutzen gerade Netz-IO in modernen Anwendungen ganz intensiv. IO ist oft das, was diese Anwendungen am meisten machen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Und auf der anderen Seite ist die
&lt;a href=&quot;https://www.researchgate.net/figure/CPU-performance-Historical-trends_fig1_321800076&quot;&gt;Hardware viel schneller als `65&lt;/a&gt;. Wir haben so viele Requests zu verarbeiten und die Rechner sind schnell genug. Das geht. Wir k√∂nnen mal eben eine Million Sockets offenhalten und damit arbeiten. Nur: das Threading selbst kommt nur mit
&lt;a href=&quot;https://www.tutorialspoint.com/what-is-the-maximum-number-of-threads-per-process-in-linux&quot;&gt;ein paar zehntausend Threads&lt;/a&gt;
klar.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Und deswegen sind inzwischen die Threads selbst die wertvolle Ressource. Und deswegen mussten wir anfangen, die Threads selbst zu teilen, zu poolen und sie wiederzuverwenden.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hierhin f√§llt der Aufstieg der
&lt;a href=&quot;https://blog.bitsrc.io/event-based-asynchronous-programming-abb0447381eb?gi=dc11417acbc0&quot;&gt;Event-basierten IO-Bibliotheken&lt;/a&gt;.
Netty f√§llt in diese Kategorie.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/20230505-loom-threading/ioloop.svg&quot; alt=&quot;IO-Thread und Worker-Thread bei der Arbeit&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 2. IO-Thread und Worker-Thread bei der Arbeit&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;IO und Worker Threads: ein speziell f√ºr IO-Operationen abgestellter Thread nimmt Daten entgegen. Dieser Thread wickelt s√§mtliche IO-Operationen ab. Damit entf√§llt auch die Notwendigkeit f√ºr Locking und Synchronisierung. Sobald Daten eingetroffen sind, werden sie in separaten Worker-Threads verarbeitet. Worker-Threads sollen selbst nie blockieren.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Es wird dabei meistens nur ein Thread (manchmal einer pro CPU)
&lt;a href=&quot;https://medium.com/@akhaku/netty-data-model-threading-and-gotchas-cab820e4815a&quot;&gt;mit IO&lt;/a&gt;
beauftragt. Er arbeitet mit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_I/O_(Java)&quot;&gt;‚Äûnon-blocking IO‚Äú&lt;/a&gt;
, erh√§lt also Events, sobald eine IO-Operation abgeschlossen ist. Dadurch kann ein Thread alle offenen Sockets auf einmal bearbeiten.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sobald das IO abgeschlossen ist, wandert die Arbeit zu einem Worker-Thread weiter, der Berechnungen vornimmt. So l√§sst sich in unserem Beispiel bei drei gleichzeitig aktiven Requests die Thread-Zahl auf zwei reduzieren.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Der Preis daf√ºr ist, dass die Worker-Threads selbst Bescheid geben m√ºssen, wenn sie fertig sind. Da ist dann das ‚Äûalte‚Äú kooperative Multitasking wieder. In der Praxis spielt das aber weniger eine Rolle, weil wir mehrere Worker-Threads benutzen, als Thread-Pool.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Trotzdem ‚Äì wir bezahlen gleich mehrere Preise daf√ºr:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;F√ºr jeden Request gibt es mindestens zwei Thread-Wechsel. Und die sind teuer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sind Teile der Anwendung rechenintensiv, dann m√ºssen wir selbst daf√ºr sorgen, dass sie niemanden blockieren. Dann gibt es mehrere Thread-Pools.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;#8230;&amp;#8203; und wir brauchen ein kluges Threading-Konzept. Meistens hei√üt das, verschiedene Pools f√ºr Rechenlast, Netzwerk und File-IO einzuf√ºhren.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Die IO-APIs sind alles andere als einfach zu bedienen. Und immer etwas anders. Netty f√ºr Netzwerk-IO. NIO f√ºr File-IO. RDBC f√ºr den Datenbankzugriff.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_threads_sind_die_grundlage_der_nebenl√§ufigkeit&quot;&gt;Threads sind die Grundlage der Nebenl√§ufigkeit&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Die Kernkonzepte von Java basieren auf Threads. Das gilt f√ºr den Sprachkern, die VM, f√ºrs Debugging und das Profiling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;IO-APIs waren synchron und sind in synchroner Form heute noch am √ºbersichtlichsten zu benutzen. Das gesamte Exception-System ergibt nur
&lt;a href=&quot;https://stackoverflow.com/questions/67631513/short-circuiting-the-chain-of-completionstage&quot;&gt;innerhalb eines Threads&lt;/a&gt;
wirklich Sinn. Speicherzugriffe innerhalb eines Threads sind geordnet und √ºberschaubar.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Wir k√∂nnten am √ºbersichtlichsten alle Arbeit f√ºr einen Request in einem eigenen Thread erledigen. Wir k√∂nnten einfach einen
&lt;a href=&quot;https://dzone.com/articles/spring-webflux-eventloop-vs-thread-per-request-mod&quot;&gt;Thread pro Request starten&lt;/a&gt;,
synchrone APIs verwenden. Aber es geht nicht, weil einfach zu wenige Threads verf√ºgbar sind.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_asynchrone_programmierung_als_notl√∂sung&quot;&gt;Asynchrone Programmierung als Notl√∂sung&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Als Konsequenz opfern wir den Java-Sprachkern und verwenden reaktive Bibliotheken. Und m√ºssen uns f√ºr Konstrukte wie Schleifen, If und Try-Catch komplett neue Konstrukte einfallen lassen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;CompletableFuture
    .supplyAsync(info::getUrl, pool)
    .thenCompose(url -&amp;gt; getBodyAsync(
        pool,
        HttpResponse.BodySubscribers.ofString(UTF_8)))
    .thenApply(info::findImage)
    .thenCompose(url -&amp;gt; getBodyAsync(
        pool,
        HttpResponse.BodySubscribers.ofByteArray()))
    .thenApply(info::setImageData)
    .thenAccept(this::process)
    .exceptionally(t -&amp;gt; { t.printStackTrace(); return null; });&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Ohne auf den konkreten Inhalt dieses Handlers einzugehen, l√§sst sich die Auswirkung auf die Struktur der Programmiersprache erkennen: Das Programm wird nicht mehr in der √ºblichen Weise strukturiert, sondern √ºber eine &quot;Fluent API&quot; erstellt und gestartet. Im Kern stellt das eine Monade dar, wie sie zum Beispiel aus Haskell bekannt ist. Dieses neue Sprachkonstrukt hat eine Reihe von Folgen, die interessant zu nutzen sind.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Mit all den Problemen, die daraus resultieren, dass jetzt JVM, Werkzeuge, Sprache und Tools nicht mehr so recht zusammenpassen wollen: In Stack Traces steht oft
&lt;a href=&quot;https://www.baeldung.com/spring-debugging-reactive-streams&quot;&gt;kaum noch Hilfreiches&lt;/a&gt;.
Mit dem Debugger durch ein reaktives Programm zu steppen ist eine Herausforderung. Und die Ursache f√ºr Lastprobleme zu finden, ist problematisch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Diesen Programmierstil verwenden wir definitiv nicht, weil er einfacher zu verstehen w√§re. Oder weil er sonst irgendwie n√ºtzlicher zu handhaben w√§re.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Wir verwenden diesen Programmierstil, weil wir nicht anders skalieren k√∂nnen.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_projekt_loom_als_rettung&quot;&gt;Projekt Loom als Rettung&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Die Idee hinter Projekt Loom: Threads m√ºssen wieder so billig werden wie damals. Es darf kein Problem sein, Millionen davon zu starten.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Die JVM mappt dazu ihre eigene Art von Threads, die dort VirtualThreads hei√üen, auf Betriebssystem-Threads. Das ist ein M:N-Mapping. Also anders als damals zu Solaris-Zeiten, als ‚ÄûGreen Threads‚Äú eben nur auf einen einzigen OS-Thread abgebildet werden konnten. Aber ziemlich so, wie es
&lt;a href=&quot;https://www.poeticoding.com/spawning-processes-in-elixir-a-gentle-introduction-to-concurrency/&quot;&gt;in Erlang&lt;/a&gt;
schon immer war. Und auch die Go-Fans lachten ja bereits √ºber uns Java-Menschen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Die JVM kann das deswegen besser als das Betriebssystem, weil es zum einen mehr Wissen besitzt (zum Beispiel √ºber Stack-Gr√∂√üen und das Speichermodell) und zum anderen, weil es Threads nicht jederzeit unterbrechen kann. Stattdessen wird nur dort unterbrochen, wo es blockierende Operationen gibt. Das sind haupts√§chlich IO-Operationen, aber auch dort, wo wir in unseren Programmen manuell synchronisieren.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Damit das funktioniert, gab es im Rahmen des Projekts Loom Anpassungen quer durch die JVM und die Basis-Bibliotheken. NIO wurde umgebaut. Das ‚Äûalte‚Äú IO wurde angepasst (und darf und soll damit ruhig wieder benutzt werden). Nur File-IO unter Windows ist noch ein Problem und dauert noch.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_virtualthreads_benutzen_ist_fast_einfacher_als_vermeiden&quot;&gt;VirtualThreads: benutzen ist (fast) einfacher als vermeiden&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Seit Java 19 k√∂nnen wir Threads sehr einfach als ‚Äûvirtual‚Äú starten:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;var thread = Thread.startVirtualThread(() -&amp;gt; { ... });&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Das ist schon alles. Die JVM k√ºmmert sich darum, dass diese VirtualThreads automatisch auf OS-Threads abgebildet werden. Normalerweise auf einen pro CPU-Kern.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In diesem VirtualThread lassen sich nach Herzens Lust blockierende Aufrufe, Locks und Sleeps in synchroner Art platzieren. Wir sollen uns keine Gedanken mehr dar√ºber machen, wie der Wettstreit um die Ressourcen l√§uft.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_anpassungen_im_eigenen_code&quot;&gt;Anpassungen im eigenen Code&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Einige Code-Konstrukte spielen nicht so gut mit VirtualThreads zusammen. Wir k√∂nnen sie ersetzen, damit der Code noch besser skaliert.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ganz weit vorne ist (jedenfalls derzeit) noch der ‚Äûsynchronized‚Äú-Block. Der h√§ngt immer an einem OS-Thread, weil er mit Betriebssystemmitteln implementiert ist. Wir wollen ihn mit ‚ÄûReentrantLock‚Äú oder noch besser mit ‚ÄûStampedLock‚Äú ersetzen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Der zweite Bereich sind JNI-Aufrufe. Die sind immer dann problematisch, wenn sie innerhalb von ‚Äûsynchronized‚Äú passieren. Vor allem, wenn wir von nativem Code wieder nach Java callen, zum Beispiel bei Callbacks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Alles das muss uns aber nicht aufhalten. In den meisten F√§llen machen ein paar wenige solche Stellen wenig aus.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_viele_frameworks_integrieren_virtualthreads_bereits&quot;&gt;Viele Frameworks integrieren VirtualThreads bereits&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Spring Boot Projekten werden wir bereits dahin gef√ºhrt, dass wir Threading an zentraler Stelle implementieren. So wie Spring Boot es intern auch bereits macht.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Wir k√∂nnen heute schon daf√ºr sorgen, dass Spring Boot auf VirtualThreads setzt:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;@Configuration
class ConfigureVirtualThreads {

    @Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)
    public AsyncTaskExecutor asyncTaskExecutor() {
        return new TaskExecutorAdapter(
                Executors.newVirtualThreadPerTaskExecutor());
    }

    @Bean
    public TomcatProtocolHandlerCustomizer&amp;lt;?&amp;gt; protocolHandlerVirtualThreadExecutorCustomizer() {
        return protocolHandler -&amp;gt; {
            protocolHandler.setExecutor(
                Executors.newVirtualThreadPerTaskExecutor());
        };
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Mit der ersten Deklaration wird Spring konfiguriert. Der neue Task-Executor, den Spring an verschiedenen Stellen f√ºr asynchrone Aufrufe nutzt, erh√§lt daf√ºr jeweils einen neuen VirtualThread, statt wie vorher einen Thread-Pool.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Die zweite Deklaration konfiguriert den eingebetteten Tomcat, mit dem Spring Boot die Web-Anfragen bearbeitet. Hier ist normalerweise ebenfalls ein Threadpool hinterlegt. Mit der Konfiguration f√§llt dieser Pool weg und es wird jedes Mal ein neuer VirtualThread zur Bearbeitung angelegt.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Das als Configuration eingef√ºgt und schon kommen Servlet-Requests bereits fertig als VirtualThread an.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Spring Boot hat VirtualThreads auf dem Schirm, passt immer mal wieder etwas an und ist schon recht weit damit, VirtualThreads sehr effizient zu nutzen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-core/pull/8180&quot;&gt;Micronaut hat ebenfalls schon Support vorbereitet&lt;/a&gt;,
der getestet werden kann.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Und f√ºr Quarkus gibt es schon
&lt;a href=&quot;https://piotrminkowski.com/2022/10/06/quarkus-with-java-virtual-threads/&quot;&gt;sehr weitreichenden Support&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Und sogar in Wildfly 27 l√§sst sich VirtualThread-Support aktivieren.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_angewohnheiten_hinterfragen&quot;&gt;Angewohnheiten hinterfragen&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Mit Projekt Loom m√ºssen wir fast nie neue Konzepte lernen. Stattdessen k√∂nnen wir alte Gewohnheiten ablegen:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ThreadPools werden in den meisten F√§llen keinen Mehrwert mehr bieten. Im Gegenteil f√ºgen sie Overhead hinzu und
&lt;a href=&quot;https://medium.com/javarevisited/is-the-thread-per-request-model-a-good-thing-after-project-loom-6d08012839e8&quot;&gt;verlangsamen den eigenen Code&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Wo wir bisher Poolen, zum Beispiel um die Anzahl gleichzeitig durchgef√ºhrter Requests zu limitieren, k√∂nnen wir wieder (wie fr√ºher) Semaphoren beim Funktionsaufruf nutzen.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_synchron_war_nie_schlecht&quot;&gt;Synchron war nie schlecht&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Und dann nat√ºrlich die Erkenntnis: f√ºr 99&amp;#160;% aller Applikationen da drau√üen war asynchrone Programmierung nie n√∂tig. Auch nicht ohne Projekt Loom. Die wenigsten haben mehr als 30.000 gleichzeitige Requests pro Service-Instanz. Moderne Hardware hat damit kein Problem, auch nicht mit 30k Betriebssystem-Threads. Und weil die Stack-Gr√∂√üe nur virtuellen Speicher angibt, haben wir auf 64-Bit-Systemen kein Problem damit.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_ausblick_structured_concurrency&quot;&gt;Ausblick: Structured Concurrency&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Bis mit Java 21 im Herbst 2023 das n√§chste LTS-Release aufschl√§gt, soll auch Structured Concurrency mit aufgenommen sein.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Damit lassen sich dann die Stellen √ºbersichtlich angehen, bei denen innerhalb einer Aufgabe Anfragen und Berechnungen parallel erfolgen sollen.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code data-lang=&quot;kotlin&quot;&gt;@GetMapping(&quot;/trains&quot;)
fun listTrainsParallel(): TrainList&amp;lt;TrainRepresentation&amp;gt; {
    val list = StructuredTaskScope.ShutdownOnSuccess&amp;lt;List&amp;lt;Train&amp;gt;&amp;gt;().use { scope -&amp;gt;
        scope.fork { serverA.listActiveSync() }
        scope.fork { serverB.listActiveSync() }
        scope.join().result().map { it.toListRepresentation() }
    }
    val count = StructuredTaskScope.ShutdownOnSuccess&amp;lt;Int&amp;gt;().use { scope -&amp;gt;
        scope.fork { serverA.countActiveSync() }
        scope.fork { serverB.countActiveSync() }
        scope.joinUntil(Instant.now().plusSeconds(15)).result()
    }
    return TrainList(list, count)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Bei den beiden Abfragen k√∂nnen wir einfach (√ºbrigens wieder als Monade) deklarieren, dass die dahinter liegenden Abfragen in separaten Threads erfolgen - im besten Fall in VirtualThreads. &quot;ShutdownOnSuccess&quot; sorgt daf√ºr, dass das erste verf√ºgbare Ergebnis gewinnt und alle anderen Threads beendet werden. Wir k√∂nnen einen Timeout mitgeben, um die Laufzeit - hier auf 15 Sekunden - zu begrenzen.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Dabei ist wichtig: Es geht bei Structured Concurrency wirklich fast nur um die Lesbarkeit und Wartbarkeit. Schneller oder Ressourcen-sparender wird es dadurch nicht.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Also: Es wird spannend im Java-√ñkosystem. Mit Projekt Loom werden tats√§chlich die Karten neu gemischt. Endlich k√∂nnen wir den Programmierstil wieder so aussuchen, wie er zu unseren Gehirnen passt.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Digitaler Blindenhund</title>
      <link>http://jbake.org/blog/2020/2020-12-15-digitaler-blindenhund.html</link>
      <pubDate>Sat, 5 Dec 2020 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2020/2020-12-15-digitaler-blindenhund.html</guid>
      <description>
      &lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_digitaler_blindenhund&quot;&gt;Digitaler Blindenhund&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_video&quot;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- endtoc --&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_digitaler_blindenhund&quot;&gt;Digitaler Blindenhund&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Marcus hat den digitalen Blindenhund erdacht&lt;/p&gt;
&lt;/div&gt;
&lt;!-- teaser --&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Eine Smartphone App, die es Menschen mit Seheinschr√§nkung am Bahnhof erm√∂glicht,
die Eingangst√ºren zu ihrem Zug selbstst√§ndig zu finden.
Im Interview mit spricht Marcus √ºber Barrierefreiheit im Allgemeinen und
bei der Darstellung von digitalen Inhalten.
Und wir sprechen √ºber die allt√§glichen Herausforderungen an Bahnh√∂fen,
zum Beispiel das Finden des richtigen Bahnsteigs.
Der digitale Blindenhund ist ein Beispiel,
wie f√ºr solche F√§lle eine Hilfe aussehen kann.
Im ersten Schritt wurde sich auf die Erkennung von T√ºren fokussiert,
da dieses Problem f√ºr Blinde eine besondere Herausforderung darstellt.
Marcus erl√§utert uns dabei die vielf√§ltigen Herausforderungen und
Ans√§tze die ausprobiert wurden,
bis sie zu einer technisch sinnvollen L√∂sung auf Basis eines neuronalen Netzes gekommen sind.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_video&quot;&gt;Video&lt;/h3&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 100%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;iframe style=&quot;border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; width: 100%; height: auto;&quot; height=&quot;315&quot; src=https://www.youtube.com/watch?v=xkJuZtK-3fM title=&quot;Digitaler Blindenhund&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Vue.js vs. Angular</title>
      <link>http://jbake.org/blog/2020/2020-05-19-5vue-js-vs-angular-was-ist-besser.html</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2020/2020-05-19-5vue-js-vs-angular-was-ist-besser.html</guid>
      <description>
      &lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_vue_js_vs_angular_was_ist_besser&quot;&gt;Vue.js vs. Angular: Was ist besser?&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_video&quot;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- endtoc --&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_vue_js_vs_angular_was_ist_besser&quot;&gt;Vue.js vs. Angular: Was ist besser?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Heute zu Gast bei #000000 #c0ffee ‚Äì Der Tech-Talk der DB Systel.&lt;/p&gt;
&lt;/div&gt;
&lt;!-- teaser --&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Von Techies f√ºr Techies: Danny Koppenhagen
Danny ist Frontend-Entwickler mit den Schwerpunkten Angular und
Vue.js und einer der Autoren des Buches
‚ÄûAngular ‚Äî Grundlagen, fortgeschrittene Themen und Best‚ÄØPractices‚Äú.
Im dx.house Berlin ber√§t er au√üerdem Kunden und
Teams in den Themen User Experience von Enterprise-L√∂sungen.
Er engagiert sich in der Web Community der DB Systel und
ist Mitglied im Themen Team Web der Architekturgilde.
Dort erarbeitet er Architektur-Standards f√ºr alle Themen Web.
Im Interview spricht er √ºber seine Erfahrungen mit Vue.js und Angular.
Er geht darauf ein, welches Framework sich f√ºr welche Anwendungszwecke eignet.
So bietet Vue.js haupts√§chlich Vorteile,
wenn es um die Integration in bestehende Anwendungen handelt und
das Team gerne JavaScript einsetzt.
Angular ist im Enterprise-Umfeld f√ºr neue Anwendungen interessant,
da es auf TypeScript aufsetzt, ein umfangreiches √ñkosystem mitbringt und
zum Beispiel Migrationsguides und
Templating-F√§higkeiten √ºber sogenannte Schematics mitbringt.
Au√üerdem erl√§utert Danny wie der aktuelle Stand der Technik f√ºr Progressive Webapps (PWA) ist.
Hier kommt es darauf an, ob alle ben√∂tigten Features des Betriebssystems angesprochen werden k√∂nnen.
Falls nicht, sollte in Erw√§gung gezogen werden eine native App zu entwickeln.
Im dritten Teil sprechen wir √ºber die Anbindung von APIs.
Um die Orchestrierung von APIs zu vereinfachen,
kann hier das Architekturmuster Backend For Frontends zum Einsatz kommen.
Das vereinfacht den Zugriff aus der Anwendung,
da die Anbindung der APIs nicht einzeln im Frontend implementiert werden muss.
Erfahre mehr zum Thema: ¬†¬†¬†‚Ä¢¬†#000000¬†#c0ffee¬†Tech-Talk¬†¬†&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_video&quot;&gt;Video&lt;/h3&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 100%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;iframe class=&quot;video-iframe&quot; frameborder=&quot;0&quot; src=&quot;https://youtu.be/O3bYfZ8tcLc&quot; title=&quot;Vue.js vs. Angular: Was ist besser?&quot; allowfullscreen=&quot;true&quot; style=&quot;border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px;  width: 100%; height: auto; aspect-ratio: 560 / 315;&quot; data-ratio=&quot;1.7777777777777777&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Spock und AsciiDoc</title>
      <link>http://jbake.org/blog/2019/2019-09-13-Spock-und-AsciiDoc.html</link>
      <pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2019/2019-09-13-Spock-und-AsciiDoc.html</guid>
      <description>
      &lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_spock_und_asciidoc_vom_test_zur_spezifikation_und_zur√ºck&quot;&gt;Spock und AsciiDoc - vom Test zur Spezifikation und zur√ºck&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_slides_und_video&quot;&gt;Slides und Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- endtoc --&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_spock_und_asciidoc_vom_test_zur_spezifikation_und_zur√ºck&quot;&gt;Spock und AsciiDoc - vom Test zur Spezifikation und zur√ºck&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Spock ist ein Testframework f√ºr Webanwendungen, mit dem man unter anderem den Behavior Driven Development Ansatz, kurz BDD, verfolgen kann.&lt;/p&gt;
&lt;/div&gt;
&lt;!-- teaser --&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Der Product Owner beschreibt das Verhalten einer Applikation und der Entwickler √ºberpr√ºft es √ºber einen automatischen Test.
Dem Entwickler reicht die Ausgabe &quot;PASSED&quot; oder &quot;FAILED&quot;, denn er kennt ja den Code seiner Tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;W√§re es nicht cool, wenn auch der Product Owner ein verst√§ndliches Dokument bek√§me?
Kein Problem!
Wir generieren √ºber ein Template einfach einen Test-Report in AsciiDoc und f√ºgen weitere erkl√§rende Texte hinzu um eine les- und ausf√ºhrbare Spezifikation zu erhalten.
Screenshots aller wichtigen Schritte bereichern die Spezifikation weiter.
Sollte aber die Spezifikation nicht am Anfang stehen?
Und warum Spezifikation, wenn wir agil sein wollen? Richtig!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Stellen wir also eine iterative Feature-Beschreibung an den Anfang und
verfeinern diese mit automatischen Tests um am Ende eine gut lesbare und verifizierbare Spezifikation des Verhaltens unseres Systems zu erhalten!
Die Vorteile liegen auf der Hand ‚Äì die Vorgehensweise verbessert die Kommunikation zwischen Product Owner und Entwicklern und
am Ende bekommen wir ein Dokument welches Ihre wertvolle Software korrekt und √ºberpr√ºfbar beschreibt.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_slides_und_video&quot;&gt;Slides und Video&lt;/h3&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;iframe class=&quot;speakerdeck-iframe&quot; frameborder=&quot;0&quot; src=&quot;https://speakerdeck.com/player/1ac034287b8d429d8e0dde25de0f6a66&quot; title=&quot;Spock and AsciiDoc - ein perfektes Paar&quot; allowfullscreen=&quot;true&quot; style=&quot;border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px;  width: 100%; height: auto; aspect-ratio: 560 / 315;&quot; data-ratio=&quot;1.7777777777777777&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;iframe style=&quot;border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; width: 100%; height: auto;&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ebc6Xa-HC48?si=nyh6Drt45gNdbj2Y&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    

  </channel> 
</rss>
